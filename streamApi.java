import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class streamApi {
    public static void main(String[] args) {
        // Stream.ofNullable: Creates a stream with a single element if the element is
        // non-null, otherwise creates an empty stream.
        String name = "John";
        Stream<String> nameStream = Stream.ofNullable(name);
        nameStream.forEach(System.out::println); // Prints: John

        String nullName = null;
        Stream<String> nullNameStream = Stream.ofNullable(nullName);
        nullNameStream.forEach(System.out::println); // Prints nothing

        // Stream.iterate: Generates an infinite sequential ordered stream where each
        // element is generated by applying a function to the previous element.
        Stream.iterate(1, n -> n + 1)
                .limit(5)
                .forEach(System.out::println); // Prints: 1, 2, 3, 4, 5

        // Collectors.collectingAndThen: Performs another action on the result of a
        // collector.
        List<String> names = List.of("John", "Doe", "Jane");
        String result = names.stream()
                .collect(Collectors.collectingAndThen(Collectors.joining(", "), str -> "[" + str + "]"));
        System.out.println(result); // Prints: [John, Doe, Jane]

        // Stream.takeWhile and Stream.dropWhile: Takes or drops elements from the
        // beginning of the stream until a condition is met.
        Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6);
        numbers.takeWhile(n -> n < 4)
                .forEach(System.out::println); // Prints: 1, 2, 3

        numbers = Stream.of(1, 2, 3, 4, 5, 6);
        numbers.dropWhile(n -> n < 4)
                .forEach(System.out::println); // Prints: 4, 5, 6

        // Collectors.teeing: Allows performing two different collectors on the same
        // input elements, then merging their results using a merge function.
        double average = Stream.of(1, 2, 3, 4, 5)
                .collect(Collectors.teeing(
                        Collectors.summingDouble(i -> i),
                        Collectors.counting(),
                        (sum, count) -> sum / count));
        System.out.println(average); // Prints: 3.0

        // Stream.concat: Concatenates two streams into one.
        Stream<Integer> firstStream = Stream.of(1, 2, 3);
        Stream<Integer> secondStream = Stream.of(4, 5, 6);
        Stream<Integer> concatStream = Stream.concat(firstStream, secondStream);
        concatStream.forEach(System.out::println); // Prints: 1, 2, 3, 4, 5, 6

        // Collectors.partitioningBy: Partitions the input elements into two groups
        // according to a predicate.
        List<String> gnames = List.of("John", "Doe", "Jane", "Alice", "Bob");
        Map<Boolean, List<String>> partitionedNames = gnames.stream()
                .collect(Collectors.partitioningBy(n -> n.length() > 3));
        System.out.println(partitionedNames); // Prints: {false=[Doe, Bob], true=[John, Jane, Alice]}

        // IntStream for Ranges: Generates a sequential ordered IntStream from
        // startInclusive (inclusive) to endExclusive (exclusive).
        IntStream.range(1, 6)
                .forEach(System.out::println); // Prints: 1, 2, 3, 4, 5

        // Stream.map: Transforms each element of the stream using the provided
        // function.
        List<String> upperCaseNames = names.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        System.out.println(upperCaseNames); // Prints: [JOHN, DOE, JANE]

        // Stream.filter: Filters the elements of the stream based on the given
        // predicate.
        List<Integer> enumbers = List.of(1, 2, 3, 4, 5, 6);
        List<Integer> evenNumbers = enumbers.stream()
                .filter(n -> n % 2 == 0)
                .collect(Collectors.toList());
        System.out.println(evenNumbers); // Prints: [2, 4, 6]

        // Stream.sorted: Sorts the elements of the stream.
        List<Integer> sortedNumbers = enumbers.stream()
                .sorted()
                .collect(Collectors.toList());
        System.out.println(sortedNumbers); // Prints: [1, 2, 3, 4, 5, 6]

        // Stream.distinct: Returns a stream consisting of the distinct elements of the
        // stream.
        List<Integer> distinctNumbers = enumbers.stream()
                .distinct()
                .collect(Collectors.toList());
        System.out.println(distinctNumbers); // Prints: [1, 2, 3, 4, 5, 6]

        // Stream.reduce: Combines the elements of the stream into a single result using
        // a binary operator.
        int sum = enumbers.stream()
                .reduce(0, Integer::sum);
        System.out.println(sum); // Prints: 21
    }
}
